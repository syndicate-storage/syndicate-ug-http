/***********************************************************************************************
 * This part is based on exposefs (https://github.com/gchaincl/exposefs) written by Gustaf Shin.
 ***********************************************************************************************/
var fs = require('fs');
var xattr = require('fs-xattr');
var Tail = require('tail').Tail;

module.exports = function(options) {
    var basepath = options.basepath || ".";
    if (basepath == "/") basepath = "";

    return {
        stat: function(path, options, fn) {
            path = basepath + path;
            fs.stat(path, function(err, data) {
                if (err) return fn(err);

                data.atime = data.atime.getTime();
                data.mtime = data.mtime.getTime();
                data.ctime = data.ctime.getTime();
                delete data.birthtime;
                fn(null, data);
            });
        },

        getxattr: function(path, options, fn) {
            var key = options.key;
            path = basepath + path;
            xattr.get(path, key, function(err, data) {
                if (err) return fn(err);

                var xval;
                xval = {
                    value: data
                };
                fn(null, xval);
            });
        },

        listxattr: function(path, options, fn) {
            path = basepath + path;
            xattr.list(path, function(err, data) {
                if (err) return fn(err);

                var xval;
                xval = {
                    keys: data
                };
                fn(null, xval);
            });
        },

        setxattr: function(path, options, fn) {
            var key = options.key;
            var val = options.val;
            path = basepath + path;
            xattr.set(path, key, val, fn);
        },

        rmxattr: function(path, options, fn) {
            var key = options.key;
            path = basepath + path;
            xattr.remove(path, key, fn);
        },

        readdir: function(path, options, fn) {
            path = basepath + path;
            fs.readdir(path, function(err, data) {
                if (err) return fn(err);

                var entries;
                entries = {
                    entries: data
                };
                fn(null, entries);
            });
        },

        readdirwithstat: function(path, options, fn) {
            path = basepath + path;
            fs.readdir(path, function(err, ddata) {
                if (err) return fn(err);

                var arr = [];
                var task_counter = 0;
                var err_in_loop = false;

                for(var i=0;i<ddata.length;i++) {
                    (function(bp, outarr, parr, idx) {
                        fs.stat(bp + parr[idx], function(err, sdata) {
                            task_counter++;

                            if (err_in_loop) {
                                return;
                            }

                            if (err) {
                                err_in_loop = true;
                                return fn(err);
                            }

                            sdata.atime = sdata.atime.getTime();
                            sdata.mtime = sdata.mtime.getTime();
                            sdata.ctime = sdata.ctime.getTime();
                            delete sdata.birthtime;
                            outarr.push({path: parr[idx], stat: sdata});

                            // return if this is the last
                            if(task_counter >= parr.length) {
                                var entries;
                                entries = {
                                    entries: outarr
                                };

                                fn(null, entries);
                            }
                        });
                    })(path, arr, ddata, i);
                }
            });
        },

        readfully: function(path, options, fn) {
            path = basepath + path;
            fs.readFile(path, fn);
        },

        open: function(path, options, fn) {
            var flags = options.flags || 'r';
            var mode = parseInt(options.mode);
            path = basepath + path;
            fs.open(path, flags, mode, fn);
        },

        read: function(path, options, fn) {
            var fd = parseInt(options.fd);
            var offset = Number(options.offset) || 0;
            var length = Number(options.length) || 0;
            var buffer = new Buffer(length);
            path = basepath + path;
            fs.read(fd, buffer, 0, length, offset, fn);
        },

        write: function(path, stream, options, fn) {
            var fd = parseInt(options.fd);
            var offset = Number(options.offset) || 0;
            var length = Number(options.length) || 0;
            var buffer = new Buffer(length);
            path = basepath + path;
            stream.on('error', fn);
            stream.on('close', fn);
            stream.on('data', function(chunk) {
                fs.write(fd, chunk, offset, fn);
                offset+=chunk.length;
            });
        },

        close: function(path, options, fn) {
            var fd = parseInt(options.fd);
            path = basepath + path;
            fs.close(fd, fn);
        },

        follow: function(path, options, fn) {
            path = basepath + path;
            var tail = new Tail(path);

            tail.on("line", function(data) {
                res.write(data + "\n");
            });

            return tail.unwatch;
        },

        mkdir: function(path, options, fn) {
            var mode = options.mode;
            path = basepath + path;
            return fs.mkdir(path, mode, fn);
        },

        writefully: function(path, stream, options, fn) {
            var flags = options.flags || 'w';
            path = basepath + path;
            target = fs.createWriteStream(path, {flags:flags, mode:mode});
            stream.pipe(target)
            .on('error', fn)
            .on('close', fn);
        },

        utimes: function(path, options, fn) {
            var now = Number(options.time) || (new Date()).getTime();
            path = basepath + path;
            fs.utimes(path, now, now, fn);
        },

        truncate: function(path, options, fn) {
            var offset = Number(options.truncate) || 0;
            path = basepath + path;
            fs.truncate(path, offset, fn);
        },

        rename: function(path, options, fn) {
            var to = options.to;
            path = basepath + path;
            fs.rename(path, to, fn);
        },

        rmdir: function(path, options, fn) {
            path = basepath + path;
            fs.rmdir(path, fn);
        },

        unlink: function(path, options, fn) {
            path = basepath + path;
            fs.unlink(path, fn);
        }
    };
};
