/***********************************************************************************************
 * This part is based on exposefs (https://github.com/gchaincl/exposefs) written by Gustaf Shin.
 ***********************************************************************************************/
var fs = require('fs');
var xattr = require('fs-xattr');
var Tail = require('tail').Tail;

module.exports = function(options) {
    var basepath = options.basepath || ".";
    if (basepath == "/") basepath = "";

    return {
        stat: function(path, options, fn) {
            path = basepath + path;
            fs.stat(path, function(err, data) {
                if (err) return fn(err);

                fn(null, data);
            });
        },

        getxattr: function(path, options, fn) {
            var key = options.key;
            path = basepath + path;
            xattr.get(path, key, fn);
        },

        listxattr: function(path, options, fn) {
            path = basepath + path;
            xattr.list(path, fn);
        },

        setxattr: function(path, options, fn) {
            var key = options.key;
            var val = options.val;
            path = basepath + path;
            xattr.set(path, key, val, fn);
        },

        rmxattr: function(path, options, fn) {
            var key = options.key;
            path = basepath + path;
            xattr.remove(path, key, fn);
        },

        readdir: function(path, options, fn) {
            path = basepath + path;
            fs.readdir(path, fn);
        },

        readdirwithstat: function(path, options, fn) {
            var entries = [];
            abspath = basepath + path;
            fs.readdir(abspath, function(err, ddata) {
                if (err) return fn(err);

                var result_cnt = 0;
                for(var i=0;i<ddata.length;i++) {
                    var pos = i;
                    fs.stat(abspath + ddata[pos], function(err, sdata) {
                        result_cnt++;

                        if (err) return fn(err);

                        entries.push({name: ddata[pos], stat: sdata});

                        // return if this is the last
                        if(result_cnt >= ddata.length) {
                            fn(null, entries);                            
                        }
                    });
                }
            });
        },

        readfully: function(path, options, fn) {
            path = basepath + path;
            fs.readFile(path, fn);
        },

        open: function(path, options, fn) {
            var flags = options.flags || 'r';
            var mode = options.mode;
            path = basepath + path;
            fs.open(path, flags, mode, fn);
        },

        read: function(path, options, fn) {
            var fd = options.fd;
            var offset = options.offset || 0;
            var length = options.length || 0;
            var buffer = new Buffer(length);
            path = basepath + path;
            fs.read(fd, buffer, offset, length, 0, fn);
        },

        write: function(path, stream, options, fn) {
            var fd = options.fd;
            var offset = options.offset || 0;
            var length = options.length || 0;
            var buffer = new Buffer(length);
            path = basepath + path;
            stream.on('error', fn);
            stream.on('close', fn);
            stream.on('data', function(chunk) {
                fs.write(fd, chunk, offset, fn);
                offset+=chunk.length;
            });
        },

        close: function(path, options, fn) {
            var fd = options.fd;
            path = basepath + path;
            fs.close(fd, fn);
        },

        follow: function(path, options, fn) {
            path = basepath + path;
            var tail = new Tail(path);

            tail.on("line", function(data) {
                res.write(data + "\n");
            });

            return tail.unwatch;
        },

        mkdir: function(path, options, fn) {
            var mode = options.mode;
            path = basepath + path;
            return fs.mkdir(path, mode, fn);
        },

        writefully: function(path, stream, options, fn) {
            var flags = options.flags || 'w';
            path = basepath + path;
            target = fs.createWriteStream(path, {flags:flags, mode:mode});
            stream.pipe(target)
            .on('error', fn)
            .on('close', fn);
        },

        utimes: function(path, options, fn) {
            var now = options.time || new Date();
            path = basepath + path;
            fs.utimes(path, now, now, fn);
        },

        truncate: function(path, options, fn) {
            var offset = options.truncate || 0;
            path = basepath + path;
            fs.truncate(path, offset, fn);
        },

        rename: function(path, options, fn) {
            var to = options.to;
            path = basepath + path;
            fs.rename(path, to, fn);
        },

        rmdir: function(path, options, fn) {
            path = basepath + path;
            fs.rmdir(path, fn);
        },

        unlink: function(path, options, fn) {
            path = basepath + path;
            fs.unlink(path, fn);
        }
    };
};
